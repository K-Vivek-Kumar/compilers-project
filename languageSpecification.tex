\documentclass{article}

\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancybox}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{datetime}
\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{enumitem}


\newdate{presentationdate}{22}{10}{2023}


\begin{document}

\begin{titlepage}
    \thisfancypage{\doublebox}{}
    \begin{center}
        \vspace*{1cm}
        \Large \textbf{CS3423 - Compilers II}
        
        \hrulefill
       
        \vspace{2cm}
        \Huge \textbf{GD}
        
        \normalsize A language for Geometry-Graph Operations
        
        \vspace{2cm}
        
        
       \large \textbf{\displaydate{presentationdate}}
        
        \large \textbf{Team Number: 10}
        
        \vspace{1.5cm}
        
        \begin{tabular}{ l  l }
            \hline
            \textbf{Name} & \textbf{Roll Number} \\
            \hline
            K Vivek Kumar & CS21BTECH11026 \\
            Bhende Adarsh Suresh & CS21BTECH11008 \\
            Jarupula Sai Kumar & CS21BTECH11023 \\
            Pathlavath Shankar & CS21BTECH11064 \\
            \hline
        \end{tabular}
        
        
    \end{center}
        
\end{titlepage}

\tableofcontents
\newpage



\section{Introduction}
This document introduces our project, which focuses on developing a Domain Specific Language (DSL) and overview of its associated compiler as part of the final course project. The DSL is designed to address specific needs within a particular domain or problem space. The compiler is the core component responsible for translating DSL code into executable instructions.
\section{Motivation}

In our quest for a groundbreaking solution, we sought to revolutionize the way we approach a recurring challenge.

\subsection{Identifying the Problem}

The conventional method of tackling geometry and graph-based problems typically involves the laborious use of pen and paper. Translating these problems into programming languages such as C and C++ can be cumbersome. To simplify and streamline this process, we embarked on a journey to craft a specialized programming language tailored specifically for solving geometric problems on graphs.

\subsection{Expanding the Concept}

Geometry, a multidimensional realm, presents a unique challenge. Operations across different dimensions share similarities, but they also exhibit significant differences. To address this issue comprehensively, we introduce a structured approach. It is essential to define the geometric context for your program one dimension at a time. This approach is pivotal, as it allows the compiler to comprehend the syntax and supported operations within each dimensional geometry.

For instance, every program intended for the GD Compiler should commence with an environment declaration, following the syntax provided below:

\begin{verbatim}
To define the geometry environment:
env:
    g1d; -------------> 1-Dimensional Geometry
    
    
env: g1d; ------------> 1-Dimensional Geometry


env:
    g2d; -------------> 2-Dimensional Geometry
    
    
env: g2d; ------------> 2-Dimensional Geometry
\end{verbatim}

\subsection{Goals}

Our DSL program aspires to provide the following key features:

\begin{enumerate}
  \item Simplification of program development.
  \item An elegant and easily comprehensible syntax.
  \item Efficient translation of geometric concepts into code.
\end{enumerate}

With these objectives in mind, we aim to redefine the way we approach and solve geometry and graph problems in the realm of programming.

\section{Data Types}

Data types can be broadly categorized into two main groups: primitive data types and non-primitive data types. In our case, we exclusively employ primitive data types.

\begin{table}[h]
\centering
\caption{Data Type Table}
\label{tab:Datatypes}
\begin{tabular}{cc}
\toprule
\textbf{Types} & \textbf{Type of Data Type} \\
\midrule
int & primitive \\
bool & primitive \\
real & primitive \\
point & primitive \\
lineseg & primitive \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Data Type Selection}

In the design and development of our domain-specific language, GD Language, for geometric operations, we have meticulously selected specific data types to represent various aspects of our language's domain. These choices are rooted in the functional requirements. Below, we provide justifications for the selection of each data type:

\subsubsection{int}
\begin{description}[leftmargin=1cm]
  \item[Usage:] Int data types are employed as the return type for various operations.
\end{description}

\subsubsection{bool}
\begin{description}[leftmargin=1cm]
  \item[Usage:] The "bool" data type serves as a representation for boolean values.
\end{description}

\subsubsection{real}
\begin{description}[leftmargin=1cm]
  \item[Usage:] The "real" data type is used to handle real values.
\end{description}
<<<<<<< HEAD

\subsubsection{point}
\begin{description}[leftmargin=1cm]
  \item[Usage:] The "point" data type is chosen to denote the location of data on a 1-dimensional line.
\end{description}

\subsubsection{lineseg}
\begin{description}[leftmargin=1cm]
  \item[Usage:] The "lineseg" data type is the selected representation for declaring a line segment on a 1-dimensional line.
\end{description}

\section{Operations}
\begin{table}[h!]
  \centering
  \caption{Operations}
  \label{tab:Operations}
  \begin{tabular}{|c|c|c|}
  \hline
  Special symbol & Action  \\
  \hline
  star &  check if  two linesegment or two point touch each other \\
  hashtag & check the overlape of two linesegment or two point  \\
  arrrow &  check if one point or linesegment is on another one\\
  addition & for incrementing the length of line segment \\
  pipe & for check if first point or linesegment is on left of second \\
  negation & used for negating the conditions\\
  \hline
  \end{tabular}
  \end{table}

\subsection{\texttt{l1 * l2}}
l1 and l2 are linegements
This command is used to check the touch between two linesegment.
\subsection{\texttt{a \# b}}
a and b are declared linesegments
This command check the overlap length between two linesegments

\subsection{\texttt{a\$->b}}
(single doller represent the first point of linesegment whereas double doller represent the second point of linesegment )

check if the first point of linesegment a is on linesegment b
\subsection{\texttt{a = a + c }}
increase the length of linesegment a by c in right direction,where c is a constant


=======

\subsubsection{point}
\begin{description}[leftmargin=1cm]
  \item[Usage:] The "point" data type is chosen to denote the location of data on a 1-dimensional line.
\end{description}

\subsubsection{lineseg}
\begin{description}[leftmargin=1cm]
  \item[Usage:] The "lineseg" data type is the selected representation for declaring a line segment on a 1-dimensional line.
\end{description}
>>>>>>> efbcc0a2a3c4fae165122c13759740905f611376
\subsection{\texttt{a = c + a}}
increase the length of linesegment a by c in left direction,where c is a constant

This method to write new content into the file.
\subsection{\texttt{a | b}}

this  will check if the linesegment a is on left of linesegment b
\subsection{\texttt{\string~(a*b)}}


This operator is for negation

\section{Statements}
Within the DSL, numerous statements play essential roles in its operations. In the following subsections, we introduce each of these statements and their specific functions.

\subsection{Comments}
Comments play a vital role in any programming language, offering a valuable way to provide program visitors with an overview of the program's purpose and functionality. In our DSL, we've incorporated the concept of comments, allowing for clear program documentation. A sample program snippet is presented below:

\subsubsection{In-Line Comment}
\begin{verbatim}
...

---------> This is a single-line comment.
------> Arrow should be atleast of size3 "-->"

...
\end{verbatim}

\subsubsection{Multi-Line Comment}
Arrow should be atleast of size \texttt{"-!>"}
\begin{verbatim}
...

---------!>
This is a multi-line comment.
It can span across multiple lines.
!>

...
\end{verbatim}

\subsection{Declaration Statements}
Declaration statements involves introducing variables of various datatypes. This can include one of the following:
\begin{enumerate}
\item Declaring number constants
\begin{verbatim}
-!> This declares a variable which can hold integer constant.!>
int <identifier>;
int i;
\end{verbatim}

\item Declaring float constants
\begin{verbatim}
-!> This declares a variable which can hold decimal constant.!>
real <identifier>;
real i;
\end{verbatim}

\item Declaring Points
\begin{verbatim}
-!> This declares a variable which can a point data on 1-dimensional axis.!>
point <identifier>;
point p;
\end{verbatim}

\item Declaring Boolean
\begin{verbatim}
-!> This declares a variable which can store a boolean variable.!>
bool <identifier>;
bool b;
\end{verbatim}

\item Declaring Line segments
\begin{verbatim}
-!> This declares a variable which can hold end points of a line segment. !>
lineseg <identifier>;
lineseg l;
\end{verbatim}
\end{enumerate}

\subsection{Check Section}
Its a combination of `if-else` and `loop` across other programming language. There is a common syntax for both these operation with a small difference in approach of implementing this.

\subsubsection{When using Check as if-else}
\begin{verbatim}
----!>
Using Check as if-else
Same like if-else ladder in C/C++.
----!>

check (condition) {
    ... ----------------------> If gets true;
} : check (condition) {
    ... ----------------------> else if gets true;
} : {
    ... ----------------------> else
}
\end{verbatim}

\subsubsection{When using Check as loop}
\begin{verbatim}
----!>
Using Check as loop
Same like while in C/C++.
----!>

check (condition) {
    ... ----------------------> If gets true;
    recheck; -----------------> Goes into as a loop to re
}
\end{verbatim}

\subsection{Main Function}
Our main function should be declared with a special keyword as \texttt{main} only.

\subsection{Functions}
\subsubsection{Function Declaration}
\begin{verbatim}
func1:
    (point a, lineseg b) => (bool) {
        ...
    }
\end{verbatim}

\subsubsection{Function Call}
\begin{verbatim}
call func1(a, b);
\end{verbatim}

\subsubsection{Example Code}

\begin{verbatim}
---------------------------------------!>
Problem Statement:
Code to 'Check in how many steps two line segments shall meet if first line segment
(length l1) started to grow (towards L2) from point x and second line segment
(length l2) started to grow (towards L1) from point y'.
---------------------------------------!>

env:
    g1d;

main:
    () => () {
        point x = 3; ------------------> Declaring the first point
        point y = 12; -----------------> Declaring the second point
        lineseg l1 = x.toright(5); ----> Declaring line segment L1
        lineseg l2 = y.toright(4); ----> Declaring line segment L2
        int a = 0; --------------------> Declaring initial step count
        check(l1 * l2) { --------------> Check if they touch
            l1 = l1 + 1; --------------> Increment 1 length from right of L1
            l2 = 1 + l2; --------------> Increment 1 length from left of L2
            a = a + 1; ----------------> Increment step count
            check; --------------------> Recheck the condition
        } -----------------------------> Shall break if check failed
        show(a); ----------------------> Print the output
    }
\end{verbatim}

\section{Lexical Stage}

\subsection{Reserved Keywords}

\begin{description}[labelwidth=5cm]
  \item[env] Describing the environment 
  \item[g1d] 1-dimensional environment
  \item[g2d] 2-dimensional environment
  \item[check] Check condition
  \item[recheck] Recheck the check
  \item[main] Main function
  \item[return] Return statement
  \item[show] Print
  \item[export] Exporting a function from the file
  \item[call] Calling a function
\end{description}

\subsection{Punctuations}

\begin{description}[labelwidth=5cm]
  \item[;] End of line
  \item[:] End of scope
  \item[=] Assignment operator
  \item[(] Start of list
  \item[)] End of list
  \item[\{] Start of scope
  \item[\}] End of scope
\end{description}
\subsection{Identifiers}
An identifier is a sequence of characters that can consist of a combination of letters (alphabets) and numbers. The identifier must begin with a letter (alphabet). It is not allowed for the identifier to be composed solely of numbers.

Regular expression for an identifier in GD Language is:

\begin{verbatim}
[a-zA-Z][a-zA-Z0-9]*
\end{verbatim}

\section{Syntax}
\subsection{Sample Programs}
\begin{enumerate}
\item \textbf{Sample Program 1}
\begin{verbatim}
---------------------------------------!>
Problem Statement:
Code to 'Check in how many steps two line segments shall meet if first line segment
(length l1) started to grow (towards L2) from point x and second line segment
(length l2) started to grow (towards L1) from point y'.
---------------------------------------!>

env:
    g1d;

main:
    () => () {
        point x = 3; ------------------> Declaring the first point
        point y = 12; -----------------> Declaring the second point
        lineseg l1 = x.toright(5); ----> Declaring line segment L1
        lineseg l2 = y.toright(4); ----> Declaring line segment L2
        int a = 0; --------------------> Declaring initial step count
        check(l1 * l2) { --------------> Check if they touch
            l1 = l1 + 1; --------------> Increment 1 length from right of L1
            l2 = 1 + l2; --------------> Increment 1 length from left of L2
            a = a + 1; ----------------> Increment step count
            check; --------------------> Recheck the condition
        } -----------------------------> Shall break if check failed
        show(a); ----------------------> Print the output
    }
\end{verbatim}
\item \textbf{Sample Program 2}
\begin{verbatim}
------------------------------------------------!>
Problem Statement:
Code to 'Find the common length as a line segment'.
------------------------------------------------!>

env: --------------------------------------------> Setting up the environment
    g1d; ----------------------------------------> Environment in 1-dimensional geometry

about commonLineSegment: ------------------------> Function declared
    (lineseg a, lineseg b) => (lineseg) { -------> arguments and returns
        check (~(a * b)) { ----------------------> Checks if a and b touches each other
            return null; ------------------------> Returns null, any-datatype
        } : check(a # b == 0) { -----------------> Length of the line segment crossed
            check(a$ -> b) { --------------------> If the first point is on b
                lineseg c = (a$, a$); -----------> Make line segment, from a to itself
                return c; -----------------------> Return that line segment
            } : { -------------------------------> If the check fails
                return (a$$, a$$); --------------> Line segment from a[2] to a[2]
            } -----------------------------------> Come out
        } : { -----------------------------------> If the check fails
            check(a | b) { ----------------------> Check if a is on the left of b
                return (b$, a$$); ---------------> Return the appropriate line
            } : { -------------------------------> If the check fails
                return (b$$, a$); ---------------> Return the appropriate line
            } -----------------------------------> Come out
        } ---------------------------------------> Come out
        return null; ----------------------------> Returns the universe datatype
    } -------------------------------------------> Come out

about main: -------------------------------------> Main function
    () => () { ----------------------------------> Arguments
        lineseg l1 = (3, 4); --------------------> Declaring a line segment
        lineseg l2 = (4, 5); --------------------> Declaring a line segment
        lineseg l = call commonLineSegment(l1, l2); ----> Calling the function
        show("Common line is ", l); -------------> Print the result out
    }
\end{verbatim}

\end{enumerate}

\section{Advantages}
The GD Language offers several advantages due to its unique design:

\begin{itemize}
    \item \textbf{User-Friendly Syntax:} GD prioritizes a user-friendly experience, making the language easy to learn and work with.

    \item \textbf{Optimized Operations:} Our compiler shall be designed to optimize each operation, ensuring efficient execution.

\end{itemize}

\section{Challenges}
Despite its advantages, GD may encounter certain challenges while development, including:

\begin{itemize}
    \item \textbf{Expanding the idea:} Introducing \texttt{g2d} and further dimensions on the language.

    \item \textbf{Loop and if-else combination:} Translation of this combination can be a difficult part.

    \item \textbf{Completeness Considerations:} Though we try to cover for nested expression workings, still the completeness can be a doubt.

\end{itemize}

\section{Conclusion}
Providing an overview of the language has been a valuable exercise in understanding the compiler's inner workings and the language's constraints. We are committed to implementing as many features as possible from this document. Please note that the features outlined are subject to refinement and further development.

\end{document}
