\documentclass{article}

\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancybox}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{datetime}
\usepackage{lipsum}

\geometry{margin=1in}

\begin{document}

\begin{titlepage}
    \thisfancypage{\doublebox}{}
    \begin{center}
        \vspace*{1cm}
        \Large \textbf{CS3423 - Compilers II}
        
        \hrulefill
       
        \vspace{2cm}
        \Huge \textbf{FILEO}
        
        \normalsize A language for file operations
        
        \vspace{2cm}
        
        
        \large \textbf{\today}
        
        \large \textbf{Team Number: 10}
        
        \vspace{1.5cm}
        
        \begin{tabular}{ l  l }
            \hline
            \textbf{Name} & \textbf{Roll Number} \\
            \hline
            K Vivek Kumar & CS21BTECH11026 \\
            Bhende Adarsh Suresh & CS21BTECH11008 \\
            Jarupula Sai Kumar & CS21BTECH11023 \\
            Pathlavath Shankar & CS21BTECH11064 \\
            \hline
        \end{tabular}
        
        
    \end{center}
        
\end{titlepage}

\tableofcontents
\newpage



\section{Introduction}
This document introduces our project, which focuses on developing a Domain Specific Language (DSL) and overview of its associated compiler as part of the final course project. The DSL is designed to address specific needs within a particular domain or problem space. The compiler is the core component responsible for translating DSL code into executable instructions.

\section{Motivation}

In our search for a new Domain-Specific Language (DSL), we aimed to find an innovative solution to a recurring problem.

\subsection{Problem Identification}

Throughout five semesters of our academic journey, we noticed the challenge of submitting assignments in a specific folder structure that's easy for computer evaluation. To address this, we want to create a language that efficiently generates the required folder structures. This will benefit all students, ensuring uniformity in structure with a single shared code.

\subsection{Expanding the Idea}

Recognizing the need for such a DSL, we decided to add more file operations for user convenience. We also plan to handle file creation differences in Linux and Windows, providing a single program for both systems for easy use and standardization.

\subsection{Goals}
Our DSL program aims to offer the following capabilities:

\begin{enumerate}
  \item Efficiently create folder structures.
  \item Perform various file operations, such as finding, renaming, replacing, emptying, and deleting.
  \item Provide a straightforward and easy-to-understand language syntax.
\end{enumerate}

\section{Data types}
Data types can be broadly categorized into two main groups: primitive data types and non-primitive data types. We are using only primitive data type.

\begin{table}[h]
\centering
\caption{Data type Table}
\label{tab:Datatypes}
\begin{tabular}{ c c c }
\hline
Types & Type of Datatype  \\
\hline
int & primitive \\
bool &primitive\\
real &primitive\\
point & primitive \\
lineseg & primitive \\

\hline
\end{tabular}
\end{table}

\subsection{Data Type Selection}
In the design and development of our domain-specific language (G1D Language) for geometric operations, we have carefully selected specific data types to represent different aspects of our language's domain. The choice of these data types is driven by the functional requirements. Below, we provide justification for the selection of each data type:

\subsubsection{int}
int datatype are used for return type of various operations

\subsubsection{bool}
The "bool" data type is for boolean values. 

\subsubsection{real}
The "real" data type is for real values.

\subsubsection{point}
The "point" data type is chosen for the location of data on 1 dimentional line.

\subsubsection{lineseg}
The "lineseg" data type is chosen for the declaration  of line segment on 1 dimentional line.

\section{Operations}
\begin{table}[h!]
  \centering
  \caption{Operations}
  \label{tab:Operations}
  \begin{tabular}{|c|c|c|}
  \hline
  Special symbol & Action  \\
  \hline
  star &  check if  two linesegment or two point touch each other \\
  hashtag & check the overlape of two linesegment or two point  \\
  arrrow &  check if one point or linesegment is on another one\\
  addition & for incrementing the length of line segment \\
  pipe & for check if first point or linesegment is on left of second \\
  \hline
  \end{tabular}
  \end{table}

\subsection{\texttt{.find("word to find"):}}

This command is used to search for a specified word within the file's content.
\subsection{\texttt{.replace("word1","word2"):}}

This command replaces all instances of "word1" with "word2" throughout the file's content.
\subsection{\texttt{.rename("newname"):}}

The .rename method is used to change the name of the file.
\subsection{\texttt{.empty():}}

This method is employed to remove all content from the file, effectively emptying it.
\subsection{\texttt{.write(string):}}

This method to write new content into the file.
\subsection{\texttt{.copy content(file):}}

This method facilitates copying the content of another file into the current file.
\subsection{\texttt{.delete():}}

This method is employed to permanently remove the file.

\section{Statements}
Within the DSL, numerous statements play essential roles in its operations. In the following subsections, we introduce each of these statements and their specific functions.

\subsection{Comments}
Comments play a vital role in any programming language, offering a valuable way to provide program visitors with an overview of the program's purpose and functionality. In our DSL, we've incorporated the concept of comments, allowing for clear program documentation enclosed within double dollar signs (\$\$). A sample program snippet is presented below:

\subsubsection{Single-Line Comment}
\begin{verbatim}
...

$$ This is a single-line comment. $$

...
\end{verbatim}

\subsubsection{Multi-Line Comment}
\begin{verbatim}
...

$$
This is a multi-line comment.
It can span across multiple lines.
$$

...
\end{verbatim}

\subsection{Folder Structure}
We have a seperate section in the code which just involves creating the folder structure. This is the first phase of working which involves in creating the folder structure easily and efficiently.
\begin{enumerate}
\item FOLDER is given with a colon (:) at the end.
\item FILE is given without a colon (:) at the end.
\end{enumerate}
The hierarchy of folder and files are distinguished with tab spaces (\texttt{\textbackslash t}). One sample program is given below:
\begin{verbatim}
CS21BTECH11026:
    TP1:
        T1:
            1.txt
            2.txt
            3.txt
            C1:
                overview.pdf
        P1:
            source_program.c
            O1:
                output_1.txt
                output_2.txt
                output_3.txt
\end{verbatim}

\subsection{Declaration Statements}
Declaration statements involves introducing variables of various datatypes. This can include one of the following:
\begin{enumerate}
\item Declaring number constants
\begin{verbatim}
$$ This declares a variable which can hold integer constant. $$
number <identifier>;
number i;
\end{verbatim}

\item Declaring string constants
\begin{verbatim}
$$ This declares a variable which can hold strings and character constant. $$
string <identifier>;
string name;
\end{verbatim}

\item Declaring Files
\begin{verbatim}
$$ This declares a variable which can hold files. $$
FILE <identifier>;
FILE f1;
\end{verbatim}

\item Declaring Folders
\begin{verbatim}
$$ This declares a variable which can hold folder. $$
FOLDER <identifier>;
FOLDER f2;
\end{verbatim}
\end{enumerate}
\subsection{Main Function}
In the second part of the language program, we are implementing the operations on various files, hence there should be a start statement for this. We have declared a function known as \texttt{svas}, which shall be translated as the \texttt{main} function as in C-language.

For example:
\begin{verbatim}
$$ This is section 1. $$
Folder:
    File1
    Folder1:
        File2
        Folder2:
    Folder3:
        File3
%%
$$ This is section 2. $$
function svas = {
    number a;
    FILE vivek;
    vivek = open("1.txt");
    a = vivek.find("/Vivek");
}
\end{verbatim}
\subsection{Functions}
\subsubsection{Function Declaration}
\begin{verbatim}
function <identifier> = <location_of_file>{
    ...
    <various operations>;
    ...
}
\end{verbatim}

\subsubsection{Function Call}
\begin{verbatim}
fun function_name;
\end{verbatim}

\subsubsection{Example Code}
\begin{verbatim}
CS21BTECH11064:
    TPY:
        1.txt
        2.txt
    TY:
       1.txt
%%
function myfunction = CS21BTECH11064/TY/{
    FILE myfile = open("1.txt");
    number k = myfile.find("word1");
    number i = myfile.replace("word1", "word2");
}

function svas = {
  fun myfunction;
}
\end{verbatim}

\section{Lexical Stage}
\subsection{Reserved Keywords}
\begin{table}[h]
\centering
\caption{Reserved Keywords in GD Language}
\label{tab:ReservedKeywords}
\begin{tabular}{|c|}
\hline
env \\
\hline
g1d \\
\hline
g2d \\
\hline
 check\\
\hline
 main\\
\hline
return\\
\hline
show\\
\hline
export \\
\hline
call \\

\hline
\end{tabular}
\end{table}
\clearpage

\caption{Punctuations in GD Language}
\label{tab:Punctuations}
\begin{tabular}{|c|}

\hline
; \\
\hline
: \\

\hline
\= \\
\hline
(\\
\hline
) \\
\hline
\{ \\
\hline
\} \\

\hline
\end{tabular}
\end{table}
\subsection{Identifiers}
An identifier is a sequence of characters that can consist of a combination of letters (alphabets) and numbers. The identifier must begin with a letter (alphabet). It is not allowed for the identifier to be composed solely of numbers.

\section{Syntax}
\subsection{Sample Programs}
\begin{enumerate}
\item \textbf{Sample Program 1}
\begin{verbatim}
Basefolder:
    Folder1:
        1.txt
        2.txt
        3.txt
    Folder2:
        Folder3:
            output.txt
        source_program.c
%%
function check = Basefolder/Folder2/Folder3{
    FILE ouput;
    output = open("output.txt");
    number i = output.find("1\n2");
}
function svas = {
    fun check;
}
\end{verbatim}
\item \textbf{Sample Program 2}
\begin{verbatim}
COMPILERS2:
    CS21BTECH11008.txt
    CS21BTECH11023.txt
    CS21BTECH11026.txt
    CS21BTECH11064.txt
CS21BTECH11026:
    TPY:
        XYZ.txt:
        Y:
            $$ This is a new folder $$
        TY:
            1.txt
            2.pdf
        T1:
            4.doc
            e.s
    TY:
        1.py
        TPY:
            folder.c
        T1:
            1.c
%%
FILE a;
$$ Ymldffhfhdfdf.g,dfg $$
function vivek = CS21BTECH11026/TY/{
    FILE vivek = open("1.txt");
    number k = vivek.find("Vivek");
    number i = vivek.replace("Vivek", "Kumar");
    number i = vivek.replace("Vivek", "Kumar", 2);
    number i = vivek.delete();
    number i = vivek.rename("2.pdf");
    string s = "Vivek\nKumar";
    vivek.copy_content(a);
    vivek.empty();
    vivek.write(s);
}
function svas = {
    fun  vivek;
}
\end{verbatim}

\end{enumerate}

\subsection{Correct vs Wrong}
From our understanding and constraints from our language design, we are mentioning some of the ambiguities which may arise.
\begin{table}[h]
\centering
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|}
\hline
\textbf{Correct Syntax} & \textbf{Wrong Syntax} \\
\hline
\begin{verbatim}
Folder1:
    File1
\end{verbatim}
&
\begin{verbatim}
Folder1:
File1
\end{verbatim}
\\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|}
\hline
\textbf{Correct Syntax} & \textbf{Wrong Syntax} \\
\hline
\begin{verbatim}
Folder1:
    Folder2:
    Folder3:
    File2
\end{verbatim}
&
\begin{verbatim}
Folder1:
    Folder2
    Folder3
    File2
\end{verbatim}
\\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|}
\hline
\textbf{Correct Syntax} & \textbf{Wrong Syntax} \\
\hline
\begin{verbatim}
Folder1:
    File1
    File2
\end{verbatim}
&
\begin{verbatim}
Folder1:
    File1, File2
\end{verbatim}
\\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|}
\hline
\textbf{Correct Syntax} & \textbf{Wrong Syntax} \\
\hline
\begin{verbatim}
Folder1:
    File1
\end{verbatim}
&
\begin{verbatim}
Folder1:
    File1
    File1
\end{verbatim}
\\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|}
\hline
\textbf{Correct Syntax} & \textbf{Wrong Syntax} \\
\hline
\begin{verbatim}
...
$$
Start of a multi-line comment
Its end.
$$
...
%%
...
$$
Start of another comment
End of the comment.
$$
...
\end{verbatim}
&
\begin{verbatim}
...
$$
Start of a multi-line comment
...
%%
...
End of the comment.
$$
...
\end{verbatim}
\\
\hline
\end{tabular}
\end{table}

\section{Advantages}
The FILEO Language offers several advantages due to its unique design:

\begin{itemize}
    \item \textbf{User-Friendly Syntax:} FILEO prioritizes a user-friendly experience, making the language easy to learn and work with.

    \item \textbf{Optimized Operations:} Our compiler is designed to optimize each file operation, ensuring efficient execution.

\end{itemize}

\section{Challenges}
Despite its advantages, FILEO may encounter certain challenges, including:

\begin{itemize}
    \item \textbf{Efficient Folder Structure Development:} Defining folder structures with tab-spaces and file names can be challenging during development.

    \item \textbf{Complex Single-Line Operations:} The flexibility of performing multiple operations in a single line may pose challenges in terms of readability and usability.

    \item \textbf{Completeness Considerations:} Issues related to file open/close management, such as inappropriate file openings or forgetting to close files, need to be carefully addressed.

\end{itemize}

\section{Conclusion}
Providing an overview of the language has been a valuable exercise in understanding the compiler's inner workings and the language's constraints. We are committed to implementing as many features as possible from this document. Please note that the features outlined are subject to refinement and further development.

\end{document}
